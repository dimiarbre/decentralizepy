import copy
import importlib
import logging

import numpy as np

from decentralizepy.sharing.SharingAsymmetric import SharingAsymmetric


class ZeroSumSharing(SharingAsymmetric):
    """
    API defining who to share with and what, and what to do on receiving

    """

    def send_all(self, neighbors, averaging_round=0):
        logging.info(
            f"Sending to all the neighbors {neighbors} for averaging step {averaging_round}"
        )
        current_model_data = self.get_data_to_send()
        current_model_data["CHANNEL"] = "DPSGD"
        current_model_data["averaging_round"] = averaging_round

        if averaging_round == 0:  # Only noise on the first averaging round
            nb_neighbors = len(neighbors)
            if self.add_self_noise:
                # To add self noise, we simulate an additional neighbor.
                nb_neighbors += 1

            # TODO: Be careful of the noise correction term that was there previously, should we keep it?
            std_to_gen = np.sqrt(nb_neighbors / (nb_neighbors - 1)) * self.noise_std
            # std_to_gen = self.noise_std

            noises = self.noise_generator.normal(
                0, std_to_gen, (nb_neighbors,) + current_model_data["params"].shape
            )

            avg_noise = np.average(noises, axis=0)
            # Normalize the noise
            noises -= avg_noise

            self.generated_noise_std = np.std(noises)
            logging.info(
                f"Total noise std: {self.generated_noise_std}, expected std {self.noise_std}. Generated with std {std_to_gen}."
            )
            logging.debug(
                f"Noise shape : {noises.shape}. Avg shape : {avg_noise.shape}."
            )
            if self.add_self_noise:
                self_model = copy.deepcopy(current_model_data)
                noise = noises[-1]
                logging.debug(
                    "Adding self noise with shape : %s. Current noise avg : %s.",
                    noise.shape,
                    np.average(noise),
                )
                self_model["params"] += noise
                self.model.load_state_dict(self.deserialized_model(self_model))

        for i, neighbor in enumerate(neighbors):
            if averaging_round == 0:
                to_send = copy.deepcopy(current_model_data)
                noise = noises[i]
                logging.debug(
                    "Current noise shape : %s. Current noise avg : %s.",
                    noise.shape,
                    np.average(noise),
                )
                to_send["params"] += noise
                if i == 0:
                    # We attack an arbitrary neighbor (always the same in a static topology)
                    self.check_and_save_sent_model(to_send["params"], neighbor)

            else:
                to_send = current_model_data
            self.communication.send(neighbor, to_send)

    def __init__(
        self,
        rank,
        machine_id,
        communication,
        mapping,
        graph,
        model,
        dataset,
        log_dir,
        compress=False,
        compression_package=None,
        compression_class=None,
        noise_std=0,
        save_models_for_attacks=-1,
        self_noise=False,
        sharing_seed=421,
        save_all_models=True,
    ):
        """
        Constructor

        Parameters
        ----------
        rank : int
            Local rank
        machine_id : int
            Global machine id
        communication : decentralizepy.communication.Communication
            Communication module used to send and receive messages
        mapping : decentralizepy.mappings.Mapping
            Mapping (rank, machine_id) -> uid
        graph : decentralizepy.graphs.Graph
            Graph representing neighbors
        model : decentralizepy.models.Model
            Model to train
        dataset : decentralizepy.datasets.Dataset
            Dataset for sharing data. Not implemented yet! TODO
        log_dir : str
            Location to write shared_params (only writing for 2 procs per machine)
        compress: bool, default False
            Wether to apply a compression method or not.
        compression_package : str
            Import path of a module that implements the compression.Compression.Compression class
        compression_class : str
            Name of the compression class inside the compression package
        noise_std: int, default 0
            The std of the original Gaussian noises generated by ZeroSum
        save_models_for_attacks: int, default -1
            The interval at which a sent model must be logged.
        self_noise: bool, default False
            Whether to also noise the local model or not
        sharing_seed: int, default 421
            The seed for the generated noises.
        save_all_models: bool, default True
            Whether to save all models for the attack, or only models for the first of each node.
        """
        self.noise_std = noise_std
        self.generated_noise_std = None
        self.add_self_noise = self_noise
        super().__init__(
            rank=rank,
            machine_id=machine_id,
            communication=communication,
            mapping=mapping,
            graph=graph,
            model=model,
            dataset=dataset,
            log_dir=log_dir,
            compress=compress,
            compression_package=compression_package,
            compression_class=compression_class,
            save_models_for_attacks=save_models_for_attacks,
            save_all_models=save_all_models,
        )
        self.seed = sharing_seed
        logging.info("Random sharing seed: %s", self.seed)
        self.noise_generator = np.random.default_rng(seed=self.seed * 1000 + self.uid)
